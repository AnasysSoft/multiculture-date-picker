{"ast":null,"code":"import { D, DD, EMPTY_STR, FR, M, MM, MMM, MO, ND, ORDINAL, PIPE, RD, SA, ST, SU, TH, TU, WE, YYYY, ZERO_STR } from \"../../constants/constants\";\nimport { KeyName } from \"../../enums/key-name.enum\";\nimport { KeyCode } from \"../../enums/key-code.enum\";\nimport * as moment from 'jalali-moment';\nexport class JalaliCalendar {\n  constructor() {\n    this.weekDays = [SU, MO, TU, WE, TH, FR, SA];\n  }\n  isDateValid(dateStr, options, validateOpts) {\n    const {\n      dateFormat,\n      minYear,\n      maxYear,\n      monthLabels\n    } = options;\n    const returnDate = this.resetDate();\n    const datesInMonth = [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29];\n    const isMonthStr = dateFormat.indexOf(MMM) !== -1;\n    const delimeters = dateFormat.match(/[^(d#my)]{1,}/g);\n    if (!dateStr || dateStr === EMPTY_STR) {\n      return returnDate;\n    }\n    const dateValues = this.getDateValue(dateStr, dateFormat, delimeters);\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    for (let dv of dateValues) {\n      if (dv.format.indexOf(ORDINAL) != -1) {\n        const dayNumber = parseInt(dv.value.replace(/\\D/g, ''));\n        const ordinalStr = dv.value.replace(/[0-9]/g, '');\n        const ordinal = this.getOrdinal(dayNumber);\n        if (ordinal !== ordinalStr) {\n          return returnDate;\n        }\n        dv.value = dv.value.replace(ST, EMPTY_STR).replace(ND, EMPTY_STR).replace(RD, EMPTY_STR).replace(TH, EMPTY_STR);\n        dv.format = dv.format.replace(ORDINAL, EMPTY_STR);\n      }\n      const {\n        value,\n        format\n      } = dv;\n      if (value && /^\\d+$/.test(value) && Number(value) === 0) {\n        return returnDate;\n      }\n      if (format.indexOf(YYYY) !== -1) {\n        year = this.getNumberByValue(dv);\n      } else if (format.indexOf(M) !== -1) {\n        month = isMonthStr ? this.getMonthNumberByMonthName(dv, monthLabels) : this.getNumberByValue(dv);\n      } else if (format.indexOf(D) !== -1) {\n        day = this.getNumberByValue(dv);\n      }\n    }\n    const {\n      validateDisabledDates,\n      selectedValue\n    } = validateOpts;\n    year = year === 0 && selectedValue ? selectedValue.year : year;\n    month = month === 0 && selectedValue ? selectedValue.month : month;\n    day = day === 0 && selectedValue ? selectedValue.day : day;\n    const today = this.getToday();\n    if (year === 0 && (month !== 0 || day !== 0)) {\n      year = today.year;\n    }\n    if (month === 0 && (year !== 0 || day !== 0)) {\n      month = today.month;\n    }\n    if (day === 0 && (year !== 0 || month !== 0)) {\n      day = today.day;\n    }\n    if (month !== -1 && day !== -1 && year !== -1) {\n      if (year < minYear || year > maxYear || month < 1 || month > 12) {\n        return returnDate;\n      }\n      const date = {\n        year,\n        month,\n        day\n      };\n      if (validateDisabledDates && this.isDisabledDate(date, options).disabled) {\n        return returnDate;\n      }\n      if (moment.jIsLeapYear(year)) {\n        datesInMonth[1] = 30;\n      }\n      if (day < 1 || day > datesInMonth[month - 1]) {\n        return returnDate;\n      }\n      // Valid date\n      return date;\n    }\n    return returnDate;\n  }\n  isDateValidDateRange(dateRangeStr, options, validateOpts) {\n    let dateRange = {\n      begin: this.resetDate(),\n      end: this.resetDate()\n    };\n    if (dateRangeStr && dateRangeStr.length) {\n      const dates = dateRangeStr.split(options.dateRangeDatesDelimiter);\n      if (dates && dates.length === 2) {\n        const [beginDate, endDate] = dates;\n        let {\n          selectedValue\n        } = validateOpts;\n        if (selectedValue) {\n          validateOpts.selectedValue = selectedValue.begin;\n        }\n        const begin = this.isDateValid(beginDate, options, validateOpts);\n        if (this.isInitializedDate(begin)) {\n          if (selectedValue) {\n            validateOpts.selectedValue = selectedValue.end;\n          }\n          const end = this.isDateValid(endDate, options, validateOpts);\n          if (this.isInitializedDate(end) && this.isDateSameOrEarlier(begin, end)) {\n            dateRange = {\n              begin,\n              end\n            };\n          }\n        }\n      }\n    }\n    return dateRange;\n  }\n  getDateValue(dateStr, dateFormat, delimeters) {\n    let del = EMPTY_STR;\n    if (delimeters) {\n      for (const d of delimeters) {\n        if (del.indexOf(d) === -1) {\n          del += d;\n        }\n      }\n    }\n    const re = new RegExp(\"[\" + del + \"]\");\n    const ds = dateStr.split(re);\n    const df = dateFormat.split(re);\n    const da = [];\n    for (let i = 0; i < df.length; i++) {\n      if (df[i].indexOf(YYYY) !== -1) {\n        da.push({\n          value: ds[i],\n          format: df[i]\n        });\n      }\n      if (df[i].indexOf(M) !== -1) {\n        da.push({\n          value: ds[i],\n          format: df[i]\n        });\n      }\n      if (df[i].indexOf(D) !== -1) {\n        da.push({\n          value: ds[i],\n          format: df[i]\n        });\n      }\n    }\n    return da;\n  }\n  getMonthNumberByMonthName(df, monthLabels) {\n    if (df.value) {\n      for (let key = 1; key <= 12; key++) {\n        if (df.value.toLowerCase() === monthLabels[key].toLowerCase()) {\n          return key;\n        }\n      }\n    }\n    return -1;\n  }\n  getNumberByValue(df) {\n    if (!/^\\d+$/.test(df.value)) {\n      return -1;\n    }\n    let nbr = Number(df.value);\n    if (df.format.length === 1 && df.value.length !== 1 && nbr < 10 || df.format.length === 1 && df.value.length !== 2 && nbr >= 10) {\n      nbr = -1;\n    } else if (df.format.length === 2 && df.value.length > 2) {\n      nbr = -1;\n    }\n    return nbr;\n  }\n  parseDefaultMonth(monthString) {\n    const month = {\n      monthTxt: EMPTY_STR,\n      monthNbr: 0,\n      year: 0\n    };\n    if (monthString !== EMPTY_STR) {\n      const split = monthString.split(monthString.match(/[^0-9]/)[0]);\n      month.monthNbr = split[0].length === 2 ? Number(split[0]) : Number(split[1]);\n      month.year = split[0].length === 2 ? Number(split[1]) : Number(split[0]);\n    }\n    return month;\n  }\n  isDisabledDate(date, options) {\n    const {\n      minYear,\n      maxYear,\n      disableUntil,\n      disableSince,\n      disableWeekends,\n      disableDates,\n      disableDateRanges,\n      disableWeekdays,\n      enableDates\n    } = options;\n    if (this.dateMatchToDates(date, enableDates)) {\n      return this.getDisabledValue(false, EMPTY_STR);\n    }\n    if (date.year < minYear && date.month === 12 || date.year > maxYear && date.month === 1) {\n      return this.getDisabledValue(true, EMPTY_STR);\n    }\n    const inputDates = disableDates;\n    const result = inputDates.find(d => {\n      return d.dates;\n    });\n    if (!result) {\n      if (this.dateMatchToDates(date, inputDates)) {\n        return this.getDisabledValue(true, EMPTY_STR);\n      }\n    } else {\n      for (const dd of inputDates) {\n        if (this.dateMatchToDates(date, dd.dates)) {\n          return this.getDisabledValue(true, dd.styleClass);\n        }\n      }\n    }\n    if (this.isDisabledByDisableUntil(date, disableUntil)) {\n      return this.getDisabledValue(true, EMPTY_STR);\n    }\n    if (this.isDisabledByDisableSince(date, disableSince)) {\n      return this.getDisabledValue(true, EMPTY_STR);\n    }\n    if (disableWeekends) {\n      const dayNbr = this.getDayNumber(date);\n      if (dayNbr === 0 || dayNbr === 6) {\n        return this.getDisabledValue(true, EMPTY_STR);\n      }\n    }\n    const dn = this.getDayNumber(date);\n    if (disableWeekdays.length > 0) {\n      for (const wd of disableWeekdays) {\n        if (dn === this.getWeekdayIndex(wd)) {\n          return this.getDisabledValue(true, EMPTY_STR);\n        }\n      }\n    }\n    if (this.isDisabledByDisableDateRange(date, date, disableDateRanges)) {\n      return this.getDisabledValue(true, EMPTY_STR);\n    }\n    return this.getDisabledValue(false, EMPTY_STR);\n  }\n  getDisabledValue(disabled, styleClass) {\n    return {\n      disabled,\n      styleClass\n    };\n  }\n  dateMatchToDates(date, dates) {\n    for (const d of dates) {\n      if ((d.year === 0 || d.year === date.year) && (d.month === 0 || d.month === date.month) && d.day === date.day) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isDisabledMonth(year, month, options) {\n    const {\n      disableUntil,\n      disableSince,\n      disableDateRanges,\n      enableDates\n    } = options;\n    const dateEnd = {\n      year,\n      month,\n      day: this.datesInMonth(month, year)\n    };\n    const dateBegin = {\n      year,\n      month,\n      day: 1\n    };\n    if (this.isDatesEnabled(dateBegin, dateEnd, enableDates)) {\n      return false;\n    }\n    if (this.isDisabledByDisableUntil(dateEnd, disableUntil)) {\n      return true;\n    }\n    if (this.isDisabledByDisableSince(dateBegin, disableSince)) {\n      return true;\n    }\n    if (this.isDisabledByDisableDateRange(dateBegin, dateEnd, disableDateRanges)) {\n      return true;\n    }\n    return false;\n  }\n  isDisabledYear(year, options) {\n    const {\n      disableUntil,\n      disableSince,\n      disableDateRanges,\n      enableDates,\n      minYear,\n      maxYear\n    } = options;\n    const dateEnd = {\n      year,\n      month: 12,\n      day: 31\n    };\n    const dateBegin = {\n      year,\n      month: 1,\n      day: 1\n    };\n    if (this.isDatesEnabled(dateBegin, dateEnd, enableDates)) {\n      return false;\n    }\n    if (this.isDisabledByDisableUntil(dateEnd, disableUntil)) {\n      return true;\n    }\n    if (this.isDisabledByDisableSince(dateBegin, disableSince)) {\n      return true;\n    }\n    if (this.isDisabledByDisableDateRange(dateBegin, dateEnd, disableDateRanges)) {\n      return true;\n    }\n    if (year < minYear || year > maxYear) {\n      return true;\n    }\n    return false;\n  }\n  isDisabledByDisableUntil(date, disableUntil) {\n    return this.isInitializedDate(disableUntil) && this.getTimeInMilliseconds(date) <= this.getTimeInMilliseconds(disableUntil);\n  }\n  isDisabledByDisableSince(date, disableSince) {\n    return this.isInitializedDate(disableSince) && this.getTimeInMilliseconds(date) >= this.getTimeInMilliseconds(disableSince);\n  }\n  isPastDatesEnabled(date, enableDates) {\n    for (const d of enableDates) {\n      if (this.getTimeInMilliseconds(d) <= this.getTimeInMilliseconds(date)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isFutureDatesEnabled(date, enableDates) {\n    for (const d of enableDates) {\n      if (this.getTimeInMilliseconds(d) >= this.getTimeInMilliseconds(date)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isDatesEnabled(dateBegin, dateEnd, enableDates) {\n    for (const d of enableDates) {\n      if (this.getTimeInMilliseconds(d) >= this.getTimeInMilliseconds(dateBegin) && this.getTimeInMilliseconds(d) <= this.getTimeInMilliseconds(dateEnd)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isDisabledByDisableDateRange(dateBegin, dateEnd, disableDateRanges) {\n    const dateMsBegin = this.getTimeInMilliseconds(dateBegin);\n    const dateMsEnd = this.getTimeInMilliseconds(dateEnd);\n    for (const d of disableDateRanges) {\n      if (this.isInitializedDate(d.begin) && this.isInitializedDate(d.end) && dateMsBegin >= this.getTimeInMilliseconds(d.begin) && dateMsEnd <= this.getTimeInMilliseconds(d.end)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isMarkedDate(date, options) {\n    const {\n      markDates,\n      markWeekends\n    } = options;\n    for (const md of markDates) {\n      if (this.dateMatchToDates(date, md.dates)) {\n        return this.getMarkedValue(true, md.color, md.styleClass);\n      }\n    }\n    if (markWeekends && markWeekends.marked) {\n      const dayNbr = this.getDayNumber(date);\n      if (dayNbr === 0 || dayNbr === 6) {\n        return this.getMarkedValue(true, markWeekends.color, EMPTY_STR);\n      }\n    }\n    return this.getMarkedValue(false, EMPTY_STR, EMPTY_STR);\n  }\n  getMarkedValue(marked, color, styleClass) {\n    return {\n      marked,\n      color: color ? color : EMPTY_STR,\n      styleClass: styleClass ? styleClass : EMPTY_STR\n    };\n  }\n  isHighlightedDate(date, options) {\n    const {\n      sunHighlight,\n      satHighlight,\n      highlightDates\n    } = options;\n    const dayNbr = this.getDayNumber(date);\n    if (sunHighlight && dayNbr === 0 || satHighlight && dayNbr === 6) {\n      return true;\n    }\n    return this.dateMatchToDates(date, highlightDates);\n  }\n  getWeekNumber(date) {\n    const d = new Date(date.year, date.month - 1, date.day, 0, 0, 0, 0);\n    d.setDate(d.getDate() + (d.getDay() === 0 ? -3 : 4 - d.getDay()));\n    return Math.round((d.getTime() - new Date(d.getFullYear(), 0, 4).getTime()) / 86400000 / 7) + 1;\n  }\n  getDateModel(date, dateRange, dateFormat, monthLabels, rangeDelimiter, dateStr = EMPTY_STR) {\n    let singleDateModel = null;\n    let dateRangeModel = null;\n    if (date) {\n      singleDateModel = {\n        date,\n        jsDate: this.myDateToJsDate(date),\n        formatted: dateStr.length ? dateStr : this.formatDate(date, dateFormat, monthLabels),\n        epoc: this.getEpocTime(date)\n      };\n    } else {\n      dateRangeModel = {\n        beginDate: dateRange.begin,\n        beginJsDate: this.myDateToJsDate(dateRange.begin),\n        beginEpoc: this.getEpocTime(dateRange.begin),\n        endDate: dateRange.end,\n        endJsDate: this.myDateToJsDate(dateRange.end),\n        endEpoc: this.getEpocTime(dateRange.end),\n        formatted: this.formatDate(dateRange.begin, dateFormat, monthLabels) + rangeDelimiter + this.formatDate(dateRange.end, dateFormat, monthLabels)\n      };\n    }\n    return {\n      isRange: date === null,\n      singleDate: singleDateModel,\n      dateRange: dateRangeModel\n    };\n  }\n  formatDate(date, dateFormat, monthLabels) {\n    let formatted = dateFormat.replace(YYYY, String(date.year));\n    if (dateFormat.indexOf(MMM) !== -1) {\n      formatted = formatted.replace(MMM, monthLabels[date.month]);\n    } else if (dateFormat.indexOf(MM) !== -1) {\n      formatted = formatted.replace(MM, this.preZero(date.month));\n    } else {\n      formatted = formatted.replace(M, String(date.month));\n    }\n    if (dateFormat.indexOf(DD) !== -1) {\n      formatted = formatted.replace(DD, this.preZero(date.day));\n    } else {\n      formatted = formatted.replace(D, String(date.day));\n    }\n    if (dateFormat.indexOf(ORDINAL) !== -1) {\n      formatted = formatted.replace(ORDINAL, this.getOrdinal(date.day));\n    }\n    return formatted;\n  }\n  getOrdinal(date) {\n    if (date > 3 && date < 21) {\n      return TH;\n    }\n    switch (date % 10) {\n      case 1:\n        return ST;\n      case 2:\n        return ND;\n      case 3:\n        return RD;\n      default:\n        return TH;\n    }\n  }\n  getFormattedDate(model) {\n    return !model.isRange ? model.singleDate.formatted : model.dateRange.formatted;\n  }\n  preZero(val) {\n    return val < 10 ? ZERO_STR + val : String(val);\n  }\n  isInitializedDate(date) {\n    return date.year !== 0 && date.month !== 0 && date.day !== 0;\n  }\n  isDateEarlier(firstDate, secondDate) {\n    return this.getTimeInMilliseconds(firstDate) < this.getTimeInMilliseconds(secondDate);\n  }\n  isDateSameOrEarlier(firstDate, secondDate) {\n    return this.getTimeInMilliseconds(firstDate) <= this.getTimeInMilliseconds(secondDate);\n  }\n  isDateSame(firstDate, secondDate) {\n    return this.getTimeInMilliseconds(firstDate) === this.getTimeInMilliseconds(secondDate);\n  }\n  isDateRangeBeginOrEndSame(dateRange, date) {\n    const dateMs = this.getTimeInMilliseconds(date);\n    return this.getTimeInMilliseconds(dateRange.begin) === dateMs || this.getTimeInMilliseconds(dateRange.end) === dateMs;\n  }\n  isDateRangeBegin(dateRange, date) {\n    const dateMs = this.getTimeInMilliseconds(date);\n    return this.getTimeInMilliseconds(dateRange.begin) === dateMs;\n  }\n  isDateRangeEnd(dateRange, date) {\n    const dateMs = this.getTimeInMilliseconds(date);\n    return this.getTimeInMilliseconds(dateRange.end) === dateMs;\n  }\n  isDateInRange(date, dateRange) {\n    if (!this.isInitializedDate(dateRange.begin) || !this.isInitializedDate(dateRange.end)) {\n      return false;\n    }\n    return this.isDateSameOrEarlier(dateRange.begin, date) && this.isDateSameOrEarlier(date, dateRange.end);\n  }\n  resetDate() {\n    return {\n      year: 0,\n      month: 0,\n      day: 0\n    };\n  }\n  getTimeInMilliseconds(date) {\n    return this.myDateToJsDate(date).getTime();\n  }\n  getToday() {\n    const date = new Date();\n    return {\n      year: date.getFullYear(),\n      month: date.getMonth() + 1,\n      day: date.getDate()\n    };\n  }\n  getDayNumber(date) {\n    return new Date(date.year, date.month - 1, date.day, 0, 0, 0, 0).getDay();\n  }\n  getWeekdayIndex(wd) {\n    return this.weekDays.indexOf(wd);\n  }\n  getEpocTime(date) {\n    return Math.round(this.getTimeInMilliseconds(date) / 1000.0);\n  }\n  jsDateToMyDate(date) {\n    return {\n      year: date.getFullYear(),\n      month: date.getMonth() + 1,\n      day: date.getDate()\n    };\n  }\n  myDateToJsDate(date) {\n    const {\n      year,\n      month,\n      day\n    } = date;\n    return new Date(year, month - 1, day, 0, 0, 0, 0);\n  }\n  datesInMonth(m, y) {\n    return new Date(y, m, 0).getDate();\n  }\n  datesInPrevMonth(m, y) {\n    const d = this.getJsDate(y, m, 1);\n    d.setMonth(d.getMonth() - 1);\n    return this.datesInMonth(d.getMonth() + 1, d.getFullYear());\n  }\n  getJsDate(year, month, day) {\n    const yearText = year.toLocaleString(\"en-us\", {\n      minimumIntegerDigits: 4\n    });\n    const monthText = month.toLocaleString(\"en-us\", {\n      minimumIntegerDigits: 2\n    });\n    const dayText = day.toLocaleString(\"en-us\", {\n      minimumIntegerDigits: 2\n    });\n    const jalaliDate = `${yearText}/${monthText}/${dayText}`;\n    const date = moment.from(jalaliDate, \"fa\", \"YYYY/MM/DD\");\n    return new Date(date.year(), date.month(), date.day(), 0, 0, 0, 0);\n  }\n  getSelectedValue(selectedValue, dateRange) {\n    if (!selectedValue) {\n      return null;\n    }\n    if (!dateRange) {\n      return selectedValue.date;\n    } else {\n      const {\n        beginDate,\n        endDate\n      } = selectedValue;\n      return {\n        begin: beginDate,\n        end: endDate\n      };\n    }\n  }\n  getKeyCodeFromEvent(event) {\n    let key = event.key || event.keyCode || event.which;\n    if (this.checkKeyName(key, KeyName.enter) || key === KeyCode.enter) {\n      return KeyCode.enter;\n    } else if (this.checkKeyName(key, KeyName.esc) || key === KeyCode.esc) {\n      return KeyCode.esc;\n    } else if (this.checkKeyName(key, KeyName.space) || key === KeyCode.space) {\n      return KeyCode.space;\n    } else if (this.checkKeyName(key, KeyName.leftArrow) || key === KeyCode.leftArrow) {\n      return KeyCode.leftArrow;\n    } else if (this.checkKeyName(key, KeyName.upArrow) || key === KeyCode.upArrow) {\n      return KeyCode.upArrow;\n    } else if (this.checkKeyName(key, KeyName.rightArrow) || key === KeyCode.rightArrow) {\n      return KeyCode.rightArrow;\n    } else if (this.checkKeyName(key, KeyName.downArrow) || key === KeyCode.downArrow) {\n      return KeyCode.downArrow;\n    } else if (this.checkKeyName(key, KeyName.tab) || key === KeyCode.tab) {\n      return KeyCode.tab;\n    } else if (this.checkKeyName(key, KeyName.shift) || key === KeyCode.shift) {\n      return KeyCode.shift;\n    } else {\n      return null;\n    }\n  }\n  checkKeyName(key, keyName) {\n    const arr = keyName.split(PIPE);\n    return arr.indexOf(key) !== -1;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}