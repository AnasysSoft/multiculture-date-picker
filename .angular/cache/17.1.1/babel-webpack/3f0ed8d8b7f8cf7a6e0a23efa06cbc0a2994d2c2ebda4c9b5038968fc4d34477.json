{"ast":null,"code":"import { ChangeDetectorRef, ComponentFactoryResolver, ComponentRef, ElementRef, EventEmitter, forwardRef, Renderer2, SimpleChanges, ViewContainerRef } from \"@angular/core\";\nimport { AbstractControl, NG_VALIDATORS, NG_VALUE_ACCESSOR } from \"@angular/forms\";\nimport { CalendarComponent } from \"./components/calendar/calendar.component\";\nimport { LocaleService } from \"./services/angular-mydatepicker.locale.service\";\nimport { UtilService } from \"./services/angular-mydatepicker.util.service\";\nimport { DefaultConfigService } from \"./services/angular-mydatepicker.config.service\";\nimport { CalToggle } from \"./enums/cal-toggle.enum\";\nimport { Year } from \"./enums/year.enum\";\nimport { KeyCode } from \"./enums/key-code.enum\";\nimport { CalAnimation } from \"./enums/cal-animation.enum\";\nimport { ANIMATION_END, ANIMATION_TIMEOUT, BODY, CLICK, DEFAULT_MONTH, DISABLED, EMPTY_STR, INNER_HTML, LOCALE, OBJECT, OPTIONS, PREVENT_CLOSE_TIMEOUT, PX, VALUE } from \"./constants/constants\";\nimport { CalendarType } from \"./enums/calendar-type.enum\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./services/angular-mydatepicker.locale.service\";\nimport * as i2 from \"./services/angular-mydatepicker.util.service\";\nimport * as i3 from \"./services/angular-mydatepicker.config.service\";\nconst NGX_DP_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => AngularMyDatePickerDirective),\n  multi: true\n};\nconst NGX_DP_VALIDATORS = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => AngularMyDatePickerDirective),\n  multi: true\n};\nexport let AngularMyDatePickerDirective = /*#__PURE__*/(() => {\n  class AngularMyDatePickerDirective {\n    constructor(localeService, utilService, vcRef, cfr, renderer, cdr, elem, config) {\n      this.localeService = localeService;\n      this.utilService = utilService;\n      this.vcRef = vcRef;\n      this.cfr = cfr;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.elem = elem;\n      this.config = config;\n      this.defaultMonth = {\n        defMonth: EMPTY_STR,\n        overrideSelection: false\n      };\n      this.dateChanged = new EventEmitter();\n      this.inputFieldChanged = new EventEmitter();\n      this.calendarViewChanged = new EventEmitter();\n      this.calendarToggle = new EventEmitter();\n      this.rangeDateSelection = new EventEmitter();\n      this.viewActivated = new EventEmitter();\n      this.cRef = null;\n      this.hostText = EMPTY_STR;\n      this.preventClose = false;\n      this.disabled = false;\n      this.selectedValue = null;\n      this.onChangeCb = () => {};\n      this.onTouchedCb = () => {};\n      this.onClickWrapper = event => this.onClick(event);\n      this.onAnimateWrapper = reason => this.animationEnd(reason);\n      this.opts = this.config.getDefaultConfig();\n      this.parseOptions(this.opts);\n    }\n    onKeyUp(event) {\n      const keyCode = this.utilService.getKeyCodeFromEvent(event);\n      if (this.ignoreKeyPress(keyCode)) {\n        return;\n      }\n      if (keyCode === KeyCode.esc) {\n        this.closeSelector(CalToggle.CloseByEsc);\n      } else {\n        const {\n          dateRange,\n          dateFormat,\n          monthLabels,\n          dateRangeDatesDelimiter\n        } = this.opts;\n        const value = this.getHostValue();\n        let dateModel = null;\n        let valid = false;\n        let validateOpts = null;\n        if (!dateRange) {\n          validateOpts = {\n            validateDisabledDates: true,\n            selectedValue: this.utilService.getSelectedValue(this.selectedValue, false)\n          };\n          const date = this.utilService.isDateValid(value, this.opts, validateOpts);\n          valid = this.utilService.isInitializedDate(date);\n          if (valid) {\n            dateModel = this.utilService.getDateModel(date, null, dateFormat, monthLabels, dateRangeDatesDelimiter);\n          }\n        } else {\n          validateOpts = {\n            validateDisabledDates: true,\n            selectedValue: this.utilService.getSelectedValue(this.selectedValue, true)\n          };\n          const range = this.utilService.isDateValidDateRange(value, this.opts, validateOpts);\n          const {\n            begin,\n            end\n          } = range;\n          valid = this.utilService.isInitializedDate(begin) && this.utilService.isInitializedDate(end);\n          if (valid) {\n            dateModel = this.utilService.getDateModel(null, range, dateFormat, monthLabels, dateRangeDatesDelimiter);\n          }\n        }\n        this.onChangeCb(dateModel);\n        this.emitInputFieldChanged(value, valid);\n      }\n    }\n    onBlur() {\n      const {\n        inputFieldValidation,\n        dateRange,\n        dateFormat,\n        monthLabels,\n        dateRangeDatesDelimiter,\n        closeSelectorOnDateSelect\n      } = this.opts;\n      if (inputFieldValidation) {\n        const value = this.getHostValue();\n        let valid = false;\n        let validateOpts = null;\n        if (!dateRange) {\n          validateOpts = {\n            validateDisabledDates: true,\n            selectedValue: this.utilService.getSelectedValue(this.selectedValue, false)\n          };\n          const date = this.utilService.isDateValid(value, this.opts, validateOpts);\n          valid = this.utilService.isInitializedDate(date);\n          if (valid && this.hostText !== value) {\n            // Valid date\n            const dateModel = this.utilService.getDateModel(date, null, dateFormat, monthLabels, dateRangeDatesDelimiter);\n            this.emitDateChanged(dateModel);\n            this.updateModel(dateModel);\n            if (closeSelectorOnDateSelect) {\n              this.closeSelector(CalToggle.CloseByDateSel);\n            }\n          }\n        } else {\n          validateOpts = {\n            validateDisabledDates: true,\n            selectedValue: this.utilService.getSelectedValue(this.selectedValue, true)\n          };\n          const dateRange = this.utilService.isDateValidDateRange(value, this.opts, validateOpts);\n          const {\n            begin,\n            end\n          } = dateRange;\n          valid = this.utilService.isInitializedDate(begin) && this.utilService.isInitializedDate(end);\n          if (valid && this.hostText !== value) {\n            // Valid date range\n            const dateModel = this.utilService.getDateModel(null, dateRange, dateFormat, monthLabels, dateRangeDatesDelimiter);\n            this.emitDateChanged(dateModel);\n            this.updateModel(dateModel);\n            if (closeSelectorOnDateSelect) {\n              this.closeSelector(CalToggle.CloseByDateSel);\n            }\n          }\n        }\n        if (!valid && this.hostText !== value) {\n          if (value === EMPTY_STR) {\n            this.clearDate();\n          } else {\n            this.onChangeCb(null);\n          }\n        }\n        this.hostText = value;\n      }\n      this.onTouchedCb();\n    }\n    onClick(event) {\n      if (this.opts.closeSelectorOnDocumentClick && !this.preventClose && event.target && this.cRef && this.elem.nativeElement !== event.target && !this.cRef.location.nativeElement.contains(event.target) && !this.disabled) {\n        this.closeSelector(CalToggle.CloseByOutClick);\n      }\n    }\n    ngOnChanges(changes) {\n      if (changes.hasOwnProperty(LOCALE)) {\n        this.setLocaleOptions();\n      }\n      if (changes.hasOwnProperty(DEFAULT_MONTH)) {\n        let dm = changes[DEFAULT_MONTH].currentValue;\n        if (typeof dm === OBJECT) {\n          if (!dm.overrideSelection) {\n            dm.overrideSelection = false;\n          }\n        } else {\n          dm = {\n            defMonth: dm,\n            overrideSelection: false\n          };\n        }\n        this.defaultMonth = dm;\n      }\n      if (changes.hasOwnProperty(OPTIONS)) {\n        this.parseOptions(changes[OPTIONS].currentValue);\n      }\n      if (this.cRef) {\n        this.cRef.instance.refreshComponent(this.opts, this.defaultMonth, this.selectedValue, this.getHostValue());\n      }\n    }\n    ngOnDestroy() {\n      this.closeCalendar();\n    }\n    setLocaleOptions() {\n      const opts = this.localeService.getLocaleOptions(CalendarType.Gregorian, this.locale);\n      Object.keys(opts).forEach(k => {\n        this.opts[k] = opts[k];\n      });\n    }\n    parseOptions(opts) {\n      if (opts) {\n        Object.keys(opts).forEach(k => {\n          this.opts[k] = opts[k];\n        });\n      }\n      const {\n        minYear,\n        maxYear,\n        openSelectorTopOfInput,\n        inline\n      } = this.opts;\n      if (minYear < Year.min) {\n        this.opts.minYear = Year.min;\n      }\n      if (maxYear > Year.max) {\n        this.opts.maxYear = Year.max;\n      }\n      if (openSelectorTopOfInput || inline) {\n        this.opts.showSelectorArrow = false;\n      }\n      if (inline) {\n        this.openCalendar();\n      }\n    }\n    writeValue(value) {\n      if (this.disabled) {\n        return;\n      }\n      let validateOpts = null;\n      const {\n        dateFormat,\n        monthLabels,\n        dateRangeDatesDelimiter,\n        inline\n      } = this.opts;\n      if (!value) {\n        this.setHostValue(EMPTY_STR);\n        this.emitInputFieldChanged(EMPTY_STR, false);\n        if (this.cRef) {\n          this.cRef.instance.resetDateValue();\n        }\n      } else if (!value.isRange && value.singleDate) {\n        // single date\n        let {\n          date,\n          jsDate\n        } = value.singleDate;\n        if (!date) {\n          date = this.utilService.jsDateToMyDate(jsDate);\n        }\n        const formatted = this.utilService.formatDate(date, dateFormat, monthLabels);\n        validateOpts = {\n          validateDisabledDates: false,\n          selectedValue: this.utilService.getSelectedValue(this.selectedValue, false)\n        };\n        const valid = this.utilService.isInitializedDate(this.utilService.isDateValid(formatted, this.opts, validateOpts));\n        if (valid) {\n          this.setHostValue(formatted);\n          this.emitInputFieldChanged(formatted, valid);\n          this.setSelectedValue(this.utilService.getDateModel(date, null, dateFormat, monthLabels, dateRangeDatesDelimiter));\n          if (this.cRef) {\n            this.cRef.instance.refreshComponent(this.opts, this.defaultMonth, this.selectedValue, this.getHostValue());\n          }\n        }\n      } else if (value.isRange && value.dateRange) {\n        // date range\n        let {\n          beginDate,\n          beginJsDate,\n          endDate,\n          endJsDate\n        } = value.dateRange;\n        if (!beginDate || !endDate) {\n          beginDate = this.utilService.jsDateToMyDate(beginJsDate);\n          endDate = this.utilService.jsDateToMyDate(endJsDate);\n        }\n        const formatted = this.utilService.formatDate(beginDate, dateFormat, monthLabels) + dateRangeDatesDelimiter + this.utilService.formatDate(endDate, dateFormat, monthLabels);\n        validateOpts = {\n          validateDisabledDates: false,\n          selectedValue: this.utilService.getSelectedValue(this.selectedValue, true)\n        };\n        const {\n          begin,\n          end\n        } = this.utilService.isDateValidDateRange(formatted, this.opts, validateOpts);\n        const valid = this.utilService.isInitializedDate(begin) && this.utilService.isInitializedDate(end);\n        if (valid) {\n          this.setHostValue(formatted);\n          this.emitInputFieldChanged(formatted, valid);\n          const dateRange = {\n            begin: beginDate,\n            end: endDate\n          };\n          this.setSelectedValue(this.utilService.getDateModel(null, dateRange, dateFormat, monthLabels, dateRangeDatesDelimiter));\n          if (this.cRef) {\n            this.cRef.instance.refreshComponent(this.opts, this.defaultMonth, this.selectedValue, this.getHostValue());\n          }\n        }\n      }\n    }\n    registerOnChange(fn) {\n      this.onChangeCb = fn;\n    }\n    registerOnTouched(fn) {\n      this.onTouchedCb = fn;\n    }\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.renderer.setProperty(this.elem.nativeElement, DISABLED, isDisabled);\n      if (isDisabled) {\n        this.closeCalendar();\n      }\n    }\n    validate(c) {\n      const value = this.getHostValue();\n      if (value === null || value === EMPTY_STR) {\n        return null;\n      }\n      let validateOpts = null;\n      if (!this.opts.dateRange) {\n        validateOpts = {\n          validateDisabledDates: true,\n          selectedValue: this.utilService.getSelectedValue(this.selectedValue, false)\n        };\n        const date = this.utilService.isDateValid(value, this.opts, validateOpts);\n        if (!this.utilService.isInitializedDate(date)) {\n          return {\n            invalidDateFormat: true\n          };\n        }\n      } else {\n        validateOpts = {\n          validateDisabledDates: true,\n          selectedValue: this.utilService.getSelectedValue(this.selectedValue, true)\n        };\n        const {\n          begin,\n          end\n        } = this.utilService.isDateValidDateRange(value, this.opts, validateOpts);\n        if (!this.utilService.isInitializedDate(begin) || !this.utilService.isInitializedDate(end)) {\n          return {\n            invalidDateFormat: true\n          };\n        }\n      }\n      return null;\n    }\n    openCalendar() {\n      if (this.disabled) {\n        return;\n      }\n      this.preventClose = true;\n      this.cdr.detectChanges();\n      if (this.cRef === null) {\n        this.cRef = this.vcRef.createComponent(this.cfr.resolveComponentFactory(CalendarComponent));\n        this.appendSelector(this.cRef.location.nativeElement);\n        this.cRef.instance.initializeComponent(this.opts, this.defaultMonth, this.selectedValue, this.getHostValue(), this.getSelectorPosition(this.elem.nativeElement), (dm, close) => {\n          this.focusToInput();\n          this.emitDateChanged(dm);\n          this.emitInputFieldChanged(this.utilService.getFormattedDate(dm), true);\n          this.updateModel(dm);\n          if (close) {\n            this.closeSelector(CalToggle.CloseByDateSel);\n          }\n        }, cvc => {\n          this.emitCalendarChanged(cvc);\n        }, rds => {\n          this.emitRangeDateSelection(rds);\n        }, va => {\n          this.emitViewActivated(va);\n        }, () => {\n          this.closeSelector(CalToggle.CloseByEsc);\n        });\n        this.emitCalendarToggle(CalToggle.Open);\n        if (!this.opts.inline) {\n          document.addEventListener(CLICK, this.onClickWrapper);\n        }\n      }\n      setTimeout(() => {\n        this.preventClose = false;\n      }, PREVENT_CLOSE_TIMEOUT);\n    }\n    closeCalendar() {\n      this.closeSelector(CalToggle.CloseByCalBtn);\n    }\n    toggleCalendar() {\n      if (this.disabled) {\n        return;\n      }\n      const isOpen = this.cRef === null;\n      if (isOpen) {\n        this.openCalendar();\n      } else {\n        this.closeSelector(CalToggle.CloseByCalBtn);\n      }\n      return isOpen;\n    }\n    clearDate() {\n      if (this.disabled) {\n        return;\n      }\n      const {\n        inline\n      } = this.opts;\n      this.setHostValue(EMPTY_STR);\n      this.emitDateChanged({\n        isRange: this.opts.dateRange,\n        singleDate: {\n          date: this.utilService.resetDate(),\n          jsDate: null,\n          formatted: EMPTY_STR,\n          epoc: 0\n        },\n        dateRange: {\n          beginDate: this.utilService.resetDate(),\n          beginJsDate: null,\n          beginEpoc: 0,\n          endDate: this.utilService.resetDate(),\n          endJsDate: null,\n          endEpoc: 0,\n          formatted: EMPTY_STR\n        }\n      });\n      this.onChangeCb(null);\n      this.onTouchedCb();\n      if (this.cRef) {\n        this.cRef.instance.clearDate();\n      }\n      if (!inline) {\n        this.closeSelector(CalToggle.CloseByCalBtn);\n      }\n    }\n    isDateValid() {\n      const value = this.getHostValue();\n      if (value === null || value === EMPTY_STR) {\n        return false;\n      }\n      let validateOpts = null;\n      if (!this.opts.dateRange) {\n        validateOpts = {\n          validateDisabledDates: true,\n          selectedValue: this.utilService.getSelectedValue(this.selectedValue, false)\n        };\n        const date = this.utilService.isDateValid(value, this.opts, validateOpts);\n        if (this.utilService.isInitializedDate(date)) {\n          this.emitInputFieldChanged(value, true);\n          return true;\n        }\n      } else {\n        validateOpts = {\n          validateDisabledDates: true,\n          selectedValue: this.utilService.getSelectedValue(this.selectedValue, true)\n        };\n        const {\n          begin,\n          end\n        } = this.utilService.isDateValidDateRange(value, this.opts, validateOpts);\n        if (this.utilService.isInitializedDate(begin) && this.utilService.isInitializedDate(end)) {\n          this.emitInputFieldChanged(value, true);\n          return true;\n        }\n      }\n      this.emitInputFieldChanged(value, false);\n      return false;\n    }\n    headerAction(headerAction) {\n      if (this.cRef) {\n        this.cRef.instance.headerAction(headerAction);\n      }\n    }\n    setHostValue(value) {\n      const {\n        divHostElement\n      } = this.opts;\n      this.hostText = value;\n      const valueType = !divHostElement.enabled ? VALUE : INNER_HTML;\n      value = valueType === INNER_HTML && value === EMPTY_STR ? divHostElement.placeholder : value;\n      this.renderer.setProperty(this.elem.nativeElement, valueType, value);\n    }\n    ignoreKeyPress(keyCode) {\n      return keyCode === KeyCode.leftArrow || keyCode === KeyCode.rightArrow || keyCode === KeyCode.upArrow || keyCode === KeyCode.downArrow || keyCode === KeyCode.tab || keyCode === KeyCode.shift;\n    }\n    animationEnd(reason) {\n      if (this.cRef) {\n        this.cRef.instance.selectorEl.nativeElement.removeEventListener(ANIMATION_END, this.onAnimateWrapper);\n        this.removeComponent();\n        this.emitCalendarToggle(reason);\n      }\n    }\n    closeSelector(reason) {\n      const {\n        inline,\n        calendarAnimation\n      } = this.opts;\n      if (this.cRef && !inline) {\n        if (calendarAnimation.out !== CalAnimation.None) {\n          const {\n            instance\n          } = this.cRef;\n          instance.selectorEl.nativeElement.addEventListener(ANIMATION_END, this.onAnimateWrapper.bind(this, reason));\n          instance.setCalendarAnimation(calendarAnimation, false);\n          // In case the animationend event is not fired\n          setTimeout(this.onAnimateWrapper.bind(this, reason), ANIMATION_TIMEOUT);\n        } else {\n          this.removeComponent();\n          this.emitCalendarToggle(reason);\n        }\n        document.removeEventListener(CLICK, this.onClickWrapper);\n      }\n    }\n    removeComponent() {\n      if (this.vcRef !== null) {\n        this.vcRef.remove(this.vcRef.indexOf(this.cRef.hostView));\n        this.cRef = null;\n      }\n    }\n    updateModel(model) {\n      this.setHostValue(this.utilService.getFormattedDate(model));\n      this.onChangeCb(model);\n      this.onTouchedCb();\n    }\n    getHostValue() {\n      const {\n        value,\n        innerHTML\n      } = this.elem.nativeElement;\n      return !this.opts.divHostElement.enabled ? value : innerHTML;\n    }\n    focusToInput() {\n      const {\n        focusInputOnDateSelect,\n        divHostElement\n      } = this.opts;\n      if (focusInputOnDateSelect && !divHostElement.enabled) {\n        setTimeout(() => {\n          this.elem.nativeElement.focus();\n        });\n      }\n    }\n    emitDateChanged(dateModel) {\n      this.dateChanged.emit(dateModel);\n      this.setSelectedValue(dateModel);\n    }\n    setSelectedValue(dateModel) {\n      const {\n        isRange,\n        dateRange,\n        singleDate\n      } = dateModel;\n      this.selectedValue = isRange ? dateRange : singleDate;\n    }\n    emitInputFieldChanged(value, valid) {\n      this.inputFieldChanged.emit({\n        value,\n        dateFormat: this.opts.dateFormat,\n        valid\n      });\n    }\n    emitCalendarChanged(cvc) {\n      this.calendarViewChanged.emit(cvc);\n    }\n    emitRangeDateSelection(rds) {\n      this.rangeDateSelection.emit(rds);\n    }\n    emitViewActivated(va) {\n      this.viewActivated.emit(va);\n    }\n    emitCalendarToggle(reason) {\n      this.calendarToggle.emit(reason);\n    }\n    appendSelector(elem) {\n      if (this.opts.appendSelectorToBody) {\n        document.querySelector(BODY).appendChild(elem);\n      }\n    }\n    getSelectorPosition(elem) {\n      let top = 0;\n      let left = 0;\n      const {\n        appendSelectorToBody,\n        openSelectorTopOfInput,\n        selectorHeight,\n        selectorWidth,\n        showSelectorArrow,\n        alignSelectorRight\n      } = this.opts;\n      if (appendSelectorToBody) {\n        const b = document.body.getBoundingClientRect();\n        const e = elem.getBoundingClientRect();\n        top = e.top - b.top;\n        left = e.left - b.left;\n      }\n      if (openSelectorTopOfInput) {\n        top = top - this.getSelectorDimension(selectorHeight) - 2;\n      } else {\n        top = top + elem.offsetHeight + (showSelectorArrow ? 12 : 2);\n      }\n      if (alignSelectorRight) {\n        left = left + elem.offsetWidth - this.getSelectorDimension(selectorWidth);\n      }\n      return {\n        top: top + PX,\n        left: left + PX\n      };\n    }\n    getSelectorDimension(value) {\n      return Number(value.replace(PX, EMPTY_STR));\n    }\n    static #_ = this.ɵfac = function AngularMyDatePickerDirective_Factory(t) {\n      return new (t || AngularMyDatePickerDirective)(i0.ɵɵdirectiveInject(i1.LocaleService), i0.ɵɵdirectiveInject(i2.UtilService), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.DefaultConfigService));\n    };\n    static #_2 = this.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n      type: AngularMyDatePickerDirective,\n      selectors: [[\"\", \"angular-mydatepicker\", \"\"]],\n      hostBindings: function AngularMyDatePickerDirective_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keyup\", function AngularMyDatePickerDirective_keyup_HostBindingHandler($event) {\n            return ctx.onKeyUp($event);\n          })(\"blur\", function AngularMyDatePickerDirective_blur_HostBindingHandler() {\n            return ctx.onBlur();\n          });\n        }\n      },\n      inputs: {\n        options: \"options\",\n        locale: \"locale\",\n        defaultMonth: \"defaultMonth\"\n      },\n      outputs: {\n        dateChanged: \"dateChanged\",\n        inputFieldChanged: \"inputFieldChanged\",\n        calendarViewChanged: \"calendarViewChanged\",\n        calendarToggle: \"calendarToggle\",\n        rangeDateSelection: \"rangeDateSelection\",\n        viewActivated: \"viewActivated\"\n      },\n      exportAs: [\"angular-mydatepicker\"],\n      features: [i0.ɵɵProvidersFeature([UtilService, LocaleService, DefaultConfigService, NGX_DP_VALUE_ACCESSOR, NGX_DP_VALIDATORS]), i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return AngularMyDatePickerDirective;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}